[
  {
    "id": 1,
    "title": "Building Secure Authentication with bcrypt",
    "date": "2023-05-15",
    "readTime": "5 min read",
    "excerpt": "Learn how to implement secure password hashing in your Node.js applications using bcrypt to protect user credentials.",
    "image": "./resource/image.png",
    "content": "<h1>Building Secure Authentication with bcrypt</h1>\n\n<p>In today's digital landscape, security is paramount. One of the most critical aspects of web application security is proper password handling. In this post, we'll explore how to implement secure authentication using bcrypt in Node.js applications.</p>\n\n<h2>Why bcrypt?</h2>\n\n<p>bcrypt is a password-hashing function designed by Niels Provos and David Mazières. It incorporates a salt to protect against rainbow table attacks and is adaptive over time, meaning we can increase the computational cost as hardware becomes faster.</p>\n\n<h2>Implementation Steps</h2>\n\n<h3>1. Installation</h3>\n<pre><code>npm install bcrypt</code></pre>\n\n<h3>2. Hashing Passwords</h3>\n<pre><code>const bcrypt = require('bcrypt');\nconst saltRounds = 12;\n\nasync function hashPassword(password) {\n    try {\n        const hash = await bcrypt.hash(password, saltRounds);\n        return hash;\n    } catch (error) {\n        throw new Error('Error hashing password');\n    }\n}</code></pre>\n\n<h3>3. Verifying Passwords</h3>\n<pre><code>async function verifyPassword(password, hash) {\n    try {\n        const match = await bcrypt.compare(password, hash);\n        return match;\n    } catch (error) {\n        throw new Error('Error verifying password');\n    }\n}</code></pre>\n\n<h2>Best Practices</h2>\n<ul>\n<li>Always use async versions of bcrypt methods</li>\n<li>Choose an appropriate salt rounds value (12 is recommended)</li>\n<li>Never store plain text passwords</li>\n<li>Implement proper error handling</li>\n<li>Use environment variables for configuration</li>\n</ul>\n\n<p>By following these practices, you can significantly enhance your application's security posture and protect your users' sensitive information from potential breaches.</p>",
    "tags": ["Node.js", "Security", "Authentication", "bcrypt", "Backend"]
  },
  {
    "id": 2,
    "title": "Mastering EJS Templating for Dynamic Web Applications",
    "date": "2023-04-22",
    "readTime": "7 min read",
    "excerpt": "Advanced techniques for creating dynamic web pages with EJS templating engine in Node.js applications.",
    "image": "#",
    "content": "<h1>Mastering EJS Templating for Dynamic Web Applications</h1>\n\n<p>EJS (Embedded JavaScript) is a simple templating language that lets you generate HTML markup with plain JavaScript. It's particularly popular in Node.js applications for server-side rendering due to its simplicity and flexibility.</p>\n\n<h2>Getting Started with EJS</h2>\n\n<h3>Installation</h3>\n<pre><code>npm install ejs</code></pre>\n\n<h3>Basic Setup in Express</h3>\n<pre><code>const express = require('express');\nconst app = express();\n\napp.set('view engine', 'ejs');\napp.set('views', './views');</code></pre>\n\n<h2>Advanced EJS Features</h2>\n\n<h3>1. Layouts and Partials</h3>\n<p>Create reusable layout templates for consistent design across your application:</p>\n\n<h4>layout.ejs</h4>\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;&lt;%= title %&gt;&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;%- include('partials/header') %&gt;\n    &lt;main&gt;\n        &lt;%- body %&gt;\n    &lt;/main&gt;\n    &lt;%- include('partials/footer') %&gt;\n&lt;/body&gt;\n&lt;/html&gt;</code></pre>\n\n<h3>2. Custom Filters</h3>\n<p>Extend EJS with custom filters for data formatting:</p>\n<pre><code>const ejs = require('ejs');\n\nejs.filters.formatDate = function(date) {\n    return new Date(date).toLocaleDateString();\n};\n\nejs.filters.uppercase = function(str) {\n    return str.toUpperCase();\n};</code></pre>\n\n<h3>3. Conditional Rendering</h3>\n<pre><code>&lt;% if (user.isAdmin) { %&gt;\n    &lt;button class=\"admin-btn\"&gt;Admin Panel&lt;/button&gt;\n&lt;% } %&gt;</code></pre>\n\n<h3>4. Loops and Data Iteration</h3>\n<pre><code>&lt;ul&gt;\n&lt;% users.forEach(function(user) { %&gt;\n    &lt;li&gt;&lt;%= user.name %&gt; - &lt;%= user.email %&gt;&lt;/li&gt;\n&lt;% }); %&gt;\n&lt;/ul&gt;</code></pre>\n\n<h2>Performance Tips</h2>\n<ul>\n<li>Enable EJS caching in production</li>\n<li>Use includes for reusable components</li>\n<li>Minimize complex logic in templates</li>\n<li>Pre-compile frequently used templates</li>\n</ul>\n\n<p>EJS provides a powerful yet simple way to create dynamic web pages while maintaining clean, readable code that separates concerns effectively.</p>",
    "tags": ["EJS", "Templating", "Node.js", "Express", "Frontend"]
  },
  {
    "id": 3,
    "title": "Express.js Best Practices for Production Applications",
    "date": "2023-03-10",
    "readTime": "10 min read",
    "excerpt": "Essential tips and patterns for building robust, secure, and scalable Express.js applications.",
    "image": "./resource/blog/Wondering how to improve security in Express_js….jpeg",
    "content": "<h1>Express.js Best Practices for Production Applications</h1>\n\n<p>Building production-ready Express.js applications requires following established best practices. This comprehensive guide covers essential patterns and techniques that will help you create robust, secure, and scalable applications.</p>\n\n<h2>Project Structure</h2>\n\n<p>Organize your Express application with a clear, maintainable structure:</p>\n<pre><code>project/\n├── controllers/\n│   ├── userController.js\n│   └── authController.js\n├── models/\n│   ├── User.js\n│   └── Product.js\n├── routes/\n│   ├── index.js\n│   ├── users.js\n│   └── api.js\n├── middleware/\n│   ├── auth.js\n│   └── validation.js\n├── utils/\n│   ├── database.js\n│   └── helpers.js\n├── config/\n│   └── database.js\n├── public/\n│   ├── css/\n│   ├── js/\n│   └── images/\n└── views/\n    ├── layouts/\n    └── partials/</code></pre>\n\n<h2>Security Best Practices</h2>\n\n<h3>1. Helmet.js for Security Headers</h3>\n<pre><code>const helmet = require('helmet');\napp.use(helmet());</code></pre>\n\n<h3>2. Input Validation and Sanitization</h3>\n<pre><code>const { body, validationResult } = require('express-validator');\n\napp.post('/register', [\n    body('email').isEmail().normalizeEmail(),\n    body('password').isLength({ min: 8 }).isStrongPassword(),\n    body('name').trim().escape().isLength({ min: 2 })\n], async (req, res) => {\n    const errors = validationResult(req);\n    if (!errors.isEmpty()) {\n        return res.status(400).json({ \n            errors: errors.array() \n        });\n    }\n    // Process valid data\n});</code></pre>\n\n<h3>3. Rate Limiting</h3>\n<pre><code>const rateLimit = require('express-rate-limit');\n\nconst authLimiter = rateLimit({\n    windowMs: 15 * 60 * 1000, // 15 minutes\n    max: 5, // limit each IP to 5 requests per windowMs\n    message: 'Too many authentication attempts, please try again later.'\n});\n\napp.use('/auth/', authLimiter);</code></pre>\n\n<h2>Performance Optimization</h2>\n\n<h3>1. Compression</h3>\n<pre><code>const compression = require('compression');\napp.use(compression());</code></pre>\n\n<h3>2. Static File Caching</h3>\n<pre><code>app.use(express.static('public', {\n    maxAge: '7d',\n    etag: false\n}));</code></pre>\n\n<h3>3. Database Connection Pooling</h3>\n<pre><code>const { Pool } = require('pg');\nconst pool = new Pool({\n    host: process.env.DB_HOST,\n    port: process.env.DB_PORT,\n    database: process.env.DB_NAME,\n    user: process.env.DB_USER,\n    password: process.env.DB_PASSWORD,\n    max: 20,\n    idleTimeoutMillis: 30000,\n    connectionTimeoutMillis: 2000,\n});</code></pre>\n\n<h2>Error Handling</h2>\n\n<h3>Async Error Wrapper</h3>\n<pre><code>const asyncHandler = fn => (req, res, next) => {\n    Promise.resolve(fn(req, res, next)).catch(next);\n};\n\n// Usage\napp.get('/users/:id', asyncHandler(async (req, res) => {\n    const user = await User.findById(req.params.id);\n    if (!user) {\n        throw new Error('User not found');\n    }\n    res.json(user);\n}));</code></pre>\n\n<h3>Global Error Handler</h3>\n<pre><code>app.use((err, req, res, next) => {\n    console.error(err.stack);\n    \n    // Mongoose validation error\n    if (err.name === 'ValidationError') {\n        return res.status(400).json({\n            error: 'Validation Error',\n            details: err.errors\n        });\n    }\n    \n    // JWT error\n    if (err.name === 'JsonWebTokenError') {\n        return res.status(401).json({\n            error: 'Invalid token'\n        });\n    }\n    \n    res.status(err.status || 500).json({\n        error: process.env.NODE_ENV === 'production' \n            ? 'Something went wrong!' \n            : err.message \n    });\n});</code></pre>\n\n<h2>Environment Configuration</h2>\n<pre><code>// config/index.js\nrequire('dotenv').config();\n\nmodule.exports = {\n    port: process.env.PORT || 3000,\n    database: {\n        url: process.env.DATABASE_URL,\n        options: {\n            useNewUrlParser: true,\n            useUnifiedTopology: true\n        }\n    },\n    jwt: {\n        secret: process.env.JWT_SECRET,\n        expiresIn: '7d'\n    },\n    cors: {\n        origin: process.env.CORS_ORIGIN || 'http://localhost:3000'\n    }\n};</code></pre>\n\n<h2>Logging and Monitoring</h2>\n<pre><code>const morgan = require('morgan');\nconst fs = require('fs');\nconst path = require('path');\n\n// Create a write stream for logging\nconst accessLogStream = fs.createWriteStream(\n    path.join(__dirname, 'access.log'), \n    { flags: 'a' }\n);\n\napp.use(morgan('combined', { stream: accessLogStream }));\napp.use(morgan('dev')); // Console logging</code></pre>\n\n<p>By following these best practices, you'll build more secure, maintainable, and performant Express.js applications that can scale effectively and provide a reliable experience for your users.</p>",
    "tags": ["Express.js", "Best Practices", "Node.js", "Security", "Performance", "Backend"]
  },

  
  {
    "id": 4,
    "title": "Building RESTful APIs with Node.js and Express",
    "date": "2023-06-10",
    "readTime": "8 min read",
    "excerpt": "Learn how to design and implement clean, scalable RESTful APIs using Node.js and Express framework.",
    "image": "#",
    "content": "<h1>Building RESTful APIs with Node.js and Express</h1>\n\n<p>RESTful APIs are the backbone of modern web applications. In this guide, we'll explore how to design and implement clean, scalable RESTful APIs using Node.js and Express framework.</p>\n\n<h2>REST Principles</h2>\n\n<p>Follow these core REST principles for well-designed APIs:</p>\n<ul>\n<li><strong>Stateless</strong>: Each request contains all necessary information</li>\n<li><strong>Client-Server</strong>: Separation of concerns</li>\n<li><strong>Cacheable</strong>: Responses should define cacheability</li>\n<li><strong>Uniform Interface</strong>: Consistent resource identification and manipulation</li>\n<li><strong>Layered System</strong>: Architecture composed of hierarchical layers</li>\n</ul>\n\n<h2>API Design Best Practices</h2>\n\n<h3>1. Resource Naming</h3>\n<pre><code>// Good\nGET /users\nGET /users/123\nPOST /users\nPUT /users/123\nDELETE /users/123\n\n// Avoid\nGET /getUsers\nPOST /createUser\nPOST /updateUser/123\nGET /deleteUser/123</code></pre>\n\n<h3>2. HTTP Status Codes</h3>\n<pre><code>// Success\n200 OK - Successful GET requests\n201 Created - Successful POST requests\n204 No Content - Successful DELETE requests\n\n// Client Errors\n400 Bad Request - Invalid input\n401 Unauthorized - Authentication required\n403 Forbidden - Insufficient permissions\n404 Not Found - Resource doesn't exist\n\n// Server Errors\n500 Internal Server Error - Generic server error\n503 Service Unavailable - Server maintenance</code></pre>\n\n<h2>Implementation Example</h2>\n\n<h3>User API Routes</h3>\n<pre><code>// routes/users.js\nconst express = require('express');\nconst router = express.Router();\nconst User = require('../models/User');\n\n// GET /users - Get all users\nrouter.get('/', async (req, res) => {\n    try {\n        const { page = 1, limit = 10 } = req.query;\n        const users = await User.find()\n            .limit(limit * 1)\n            .skip((page - 1) * limit)\n            .sort({ createdAt: -1 });\n        \n        const count = await User.countDocuments();\n        \n        res.json({\n            users,\n            totalPages: Math.ceil(count / limit),\n            currentPage: page,\n            totalUsers: count\n        });\n    } catch (error) {\n        res.status(500).json({ error: error.message });\n    }\n});\n\n// GET /users/:id - Get single user\nrouter.get('/:id', async (req, res) => {\n    try {\n        const user = await User.findById(req.params.id);\n        if (!user) {\n            return res.status(404).json({ error: 'User not found' });\n        }\n        res.json(user);\n    } catch (error) {\n        res.status(500).json({ error: error.message });\n    }\n});\n\n// POST /users - Create new user\nrouter.post('/', async (req, res) => {\n    try {\n        const user = new User(req.body);\n        await user.save();\n        res.status(201).json(user);\n    } catch (error) {\n        res.status(400).json({ error: error.message });\n    }\n});\n\nmodule.exports = router;</code></pre>\n\n<h2>API Versioning</h2>\n\n<h3>URL Versioning</h3>\n<pre><code>// routes/v1/users.js\n// routes/v2/users.js\n\napp.use('/api/v1/users', require('./routes/v1/users'));\napp.use('/api/v2/users', require('./routes/v2/users'));</code></pre>\n\n<h2>Response Formatting</h2>\n\n<h3>Success Response</h3>\n<pre><code>{\n    \"success\": true,\n    \"data\": {\n        \"id\": \"123\",\n        \"name\": \"John Doe\",\n        \"email\": \"john@example.com\"\n    },\n    \"message\": \"User retrieved successfully\"\n}</code></pre>\n\n<h3>Error Response</h3>\n<pre><code>{\n    \"success\": false,\n    \"error\": {\n        \"code\": \"VALIDATION_ERROR\",\n        \"message\": \"Email is required\",\n        \"details\": [\n            {\n                \"field\": \"email\",\n                \"message\": \"Email is required\"\n            }\n        ]\n    }\n}</code></pre>\n\n<h2>Security Considerations</h2>\n\n<h3>1. Input Validation</h3>\n<pre><code>const Joi = require('joi');\n\nconst userSchema = Joi.object({\n    name: Joi.string().min(2).max(50).required(),\n    email: Joi.string().email().required(),\n    password: Joi.string().min(8).required()\n});</code></pre>\n\n<h3>2. Rate Limiting</h3>\n<pre><code>const limiter = rateLimit({\n    windowMs: 15 * 60 * 1000, // 15 minutes\n    max: 100 // limit each IP to 100 requests per windowMs\n});\n\napp.use('/api/', limiter);</code></pre>\n\n<h2>Testing Your API</h2>\n\n<h3>Using Jest and Supertest</h3>\n<pre><code>const request = require('supertest');\nconst app = require('../app');\n\ndescribe('User API', () => {\n    test('GET /api/users should return all users', async () => {\n        const response = await request(app)\n            .get('/api/users')\n            .expect(200);\n        \n        expect(response.body.success).toBe(true);\n        expect(Array.isArray(response.body.data)).toBe(true);\n    });\n});</code></pre>\n\n<p>By following these patterns and best practices, you can create robust, scalable RESTful APIs that are easy to maintain, secure, and provide excellent developer experience for API consumers.</p>",
    "tags": ["REST API", "Node.js", "Express", "Backend", "API Design"]
  },
  {
    "id": 5,
    "title": "Modern JavaScript ES6+ Features Every Developer Should Know",
    "date": "2023-07-05",
    "readTime": "6 min read",
    "excerpt": "Explore essential ES6+ features that will make your JavaScript code more readable, maintainable, and efficient.",
    "image": "#",
    "content": "<h1>Modern JavaScript ES6+ Features Every Developer Should Know</h1>\n\n<p>ECMAScript 2015 (ES6) and subsequent versions have introduced powerful features that have transformed JavaScript development. In this post, we'll explore essential ES6+ features that will make your code more readable, maintainable, and efficient.</p>\n\n<h2>1. Arrow Functions</h2>\n\n<p>Arrow functions provide a concise syntax and lexical <code>this</code> binding:</p>\n\n<h3>Traditional Function</h3>\n<pre><code>const multiply = function(a, b) {\n    return a * b;\n};</code></pre>\n\n<h3>Arrow Function</h3>\n<pre><code>const multiply = (a, b) => a * b;\n\n// Multiple lines\nconst calculate = (a, b) => {\n    const sum = a + b;\n    const product = a * b;\n    return { sum, product };\n};</code></pre>\n\n<h2>2. Template Literals</h2>\n\n<p>Template literals make string interpolation and multi-line strings much cleaner:</p>\n\n<h3>Before ES6</h3>\n<pre><code>const name = 'John';\nconst message = 'Hello, ' + name + '! Welcome to our website.';\n\nconst multiLine = 'This is line 1\\n' +\n                 'This is line 2\\n' +\n                 'This is line 3';</code></pre>\n\n<h3>With Template Literals</h3>\n<pre><code>const name = 'John';\nconst message = `Hello, ${name}! Welcome to our website.`;\n\nconst multiLine = `This is line 1\nThis is line 2\nThis is line 3`;\n\n// Expressions\nconst calculation = `The sum is: ${5 + 3}`; // \"The sum is: 8\"</code></pre>\n\n<h2>3. Destructuring Assignment</h2>\n\n<p>Destructuring allows you to extract values from arrays or properties from objects into distinct variables:</p>\n\n<h3>Array Destructuring</h3>\n<pre><code>const numbers = [1, 2, 3, 4, 5];\n\n// Traditional\nconst first = numbers[0];\nconst second = numbers[1];\n\n// Destructuring\nconst [first, second, ...rest] = numbers;\nconsole.log(first); // 1\nconsole.log(second); // 2\nconsole.log(rest); // [3, 4, 5]</code></pre>\n\n<h3>Object Destructuring</h3>\n<pre><code>const user = {\n    name: 'John Doe',\n    age: 30,\n    email: 'john@example.com',\n    address: {\n        city: 'New York',\n        country: 'USA'\n    }\n};\n\n// Traditional\nconst name = user.name;\nconst age = user.age;\n\n// Destructuring\nconst { name, age, address: { city } } = user;\nconsole.log(name); // \"John Doe\"\nconsole.log(city); // \"New York\"\n\n// With renaming\nconst { name: userName, age: userAge } = user;</code></pre>\n\n<h2>4. Spread and Rest Operators</h2>\n\n<h3>Spread Operator (...)</h3>\n<pre><code>// Arrays\nconst arr1 = [1, 2, 3];\nconst arr2 = [4, 5, 6];\nconst combined = [...arr1, ...arr2]; // [1, 2, 3, 4, 5, 6]\n\n// Objects\nconst obj1 = { a: 1, b: 2 };\nconst obj2 = { c: 3, d: 4 };\nconst merged = { ...obj1, ...obj2 }; // { a: 1, b: 2, c: 3, d: 4 }</code></pre>\n\n<h3>Rest Operator (...)</h3>\n<pre><code>// In functions\nfunction sum(...numbers) {\n    return numbers.reduce((total, num) => total + num, 0);\n}\nsum(1, 2, 3, 4); // 10\n\n// In destructuring\nconst [first, second, ...others] = [1, 2, 3, 4, 5];\nconsole.log(others); // [3, 4, 5]</code></pre>\n\n<h2>5. Promises and Async/Await</h2>\n\n<h3>Promises</h3>\n<pre><code>function fetchData() {\n    return new Promise((resolve, reject) => {\n        setTimeout(() => {\n            resolve('Data received');\n        }, 1000);\n    });\n}\n\nfetchData()\n    .then(data => console.log(data))\n    .catch(error => console.error(error));</code></pre>\n\n<h3>Async/Await</h3>\n<pre><code>async function getData() {\n    try {\n        const data = await fetchData();\n        console.log(data);\n    } catch (error) {\n        console.error(error);\n    }\n}\n\ngetData();</code></pre>\n\n<h2>6. Modules (Import/Export)</h2>\n\n<h3>Exporting</h3>\n<pre><code>// math.js\nexport const PI = 3.14159;\n\nexport function add(a, b) {\n    return a + b;\n}\n\nexport default function multiply(a, b) {\n    return a * b;\n}</code></pre>\n\n<h3>Importing</h3>\n<pre><code>// app.js\nimport multiply, { PI, add } from './math.js';\n\nconsole.log(PI); // 3.14159\nconsole.log(add(2, 3)); // 5\nconsole.log(multiply(2, 3)); // 6</code></pre>\n\n<h2>7. Optional Chaining (?.)</h2>\n\n<p>Safely access nested object properties without checking for existence:</p>\n\n<h3>Before Optional Chaining</h3>\n<pre><code>const city = user && user.address && user.address.city;</code></pre>\n\n<h3>With Optional Chaining</h3>\n<pre><code>const city = user?.address?.city;</n\n// Also works with function calls\nconst result = obj.someMethod?.();</code></pre>\n\n<h2>8. Nullish Coalescing (??)</h2>\n\n<p>Provides a default value only when the variable is null or undefined:</p>\n\n<pre><code>const value = null;\nconst defaultValue = 'default';\n\n// Logical OR (||) - considers falsy values\nconst result1 = value || defaultValue; // 'default'\n\n// Nullish Coalescing (??) - only null/undefined\nconst result2 = value ?? defaultValue; // 'default'\n\nconst emptyString = '';\nconst orResult = emptyString || 'default'; // 'default'\nconst nullishResult = emptyString ?? 'default'; // ''</code></pre>\n\n<h2>Benefits of Modern JavaScript</h2>\n\n<ul>\n<li><strong>Cleaner Code</strong>: More concise and readable syntax</li>\n<li><strong>Better Performance</strong>: Optimized language features</li>\n<li><strong>Enhanced Productivity</strong>: Less boilerplate code</li>\n<li><strong>Improved Maintainability</strong>: Consistent patterns and practices</li>\n<li><strong>Modern Tooling</strong>: Better support in development tools</li>\n</ul>\n\n<p>By mastering these ES6+ features, you'll write more modern, efficient, and maintainable JavaScript code that leverages the full power of the language.</p>",
    "tags": ["JavaScript", "ES6", "Modern JS", "Web Development", "Frontend"]
  }
]